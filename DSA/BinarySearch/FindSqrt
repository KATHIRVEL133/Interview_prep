Here are **clear and simple notes** for your code ðŸ‘‡

---

## ðŸ”¹ **Program Purpose**

This program finds the **floor value of the square root** of a given number `n` using **Binary Search**.

---

## ðŸ”¹ **Concept â€“ Floor Square Root**

The **floor square root** of a number is the **largest integer** whose square is **less than or equal to** the number.
For example:

* âˆš28 â‰ˆ 5.29 â†’ floor(âˆš28) = **5**

---

## ðŸ”¹ **Logic Explanation**

### ðŸ§© Step 1: Initialization

* `low = 1`, `high = n` â†’ search range for the answer.
* The answer lies between 1 and `n`.

---

### ðŸ§© Step 2: Binary Search Process

We repeatedly check the **midpoint** of the range:

1. Compute
   `mid = (low + high) / 2`
   `val = mid * mid` (square of mid)

2. **Compare `val` with `n`:**

   * If `val â‰¤ n` â†’

     * `mid` could be the answer, but there might be a bigger one.
     * Move right: `low = mid + 1`
   * If `val > n` â†’

     * `mid` is too large, move left: `high = mid - 1`

3. Continue until `low > high`.

---

### ðŸ§© Step 3: Return Result

After the loop ends,

* `high` will hold the **largest integer** whose square â‰¤ `n`.
* Hence, return `high`.

---

## ðŸ”¹ **Example**

**Input:**
`n = 28`

**Steps:**

* mid = 14 â†’ 14Â² = 196 > 28 â†’ high = 13
* mid = 7 â†’ 49 > 28 â†’ high = 6
* mid = 3 â†’ 9 < 28 â†’ low = 4
* mid = 5 â†’ 25 < 28 â†’ low = 6
* mid = 6 â†’ 36 > 28 â†’ high = 5 â†’ stop

âœ… **Output:**

```
The floor of square root of 28 is: 5
```

---

## ðŸ”¹ **Complexity**

* **Time Complexity:** O(log N) â†’ binary search reduces range by half each step
* **Space Complexity:** O(1) â†’ constant extra space

---

## ðŸ§  **Summary**

âœ… Finds the integer part (floor) of âˆšn
âœ… Uses efficient binary search instead of linear or built-in methods
âœ… Prevents overflow by using `long` for multiplication
