Here are the **structured coding notes** for your program ğŸ‘‡

---

### **Problem:**

Find the **peak element** in an array.
A **peak element** is one that is **greater than both of its neighbors**.

---

### **Intuition:**

In a **mountain-like array**, a peak exists where elements first increase and then decrease.
Example: `[1, 2, 3, 4, 5, 3, 1]` â†’ `5` is the **peak**.

We can find the peak efficiently using **binary search** instead of scanning linearly.

---

### **Approach / Steps:**

#### **1ï¸âƒ£ Handle Edge Cases:**

* If array has only **one element**, itâ€™s the peak â†’ return index `0`.
* If the **first element** is greater than the second â†’ itâ€™s a peak â†’ return index `0`.
* If the **last element** is greater than the second last â†’ itâ€™s a peak â†’ return `n - 1`.

---

#### **2ï¸âƒ£ Binary Search Setup:**

* Set two pointers:

  ```
  low = 1, high = n - 2
  ```

  (exclude already checked edges)

---

#### **3ï¸âƒ£ Check the Middle Element (`mid`):**

* If `arr[mid]` is **greater than both neighbors**:

  ```
  arr[mid-1] < arr[mid] && arr[mid] > arr[mid+1]
  ```

  â†’ Itâ€™s the **peak element** â†’ return `mid`.

---

#### **4ï¸âƒ£ Move the Search Boundaries:**

* If we are in the **increasing region** (left slope of mountain):

  ```
  arr[mid] > arr[mid-1]
  ```

  â†’ Move right â†’ `low = mid + 1`

* Else (we are in the **decreasing region** or plateau):
  â†’ Move left â†’ `high = mid - 1`

---

#### **5ï¸âƒ£ Dummy Return:**

If no element found (theoretically impossible for valid inputs), return `-1`.

---

### **Example Walkthrough:**

**Input:**
`arr = [1, 2, 3, 4, 5, 6, 7, 8, 5, 1]`

**Process:**

| low | high | mid | arr[mid] | Condition             | Action     |
| --- | ---- | --- | -------- | --------------------- | ---------- |
| 1   | 8    | 4   | 5        | increasing            | move right |
| 5   | 8    | 6   | 7        | increasing            | move right |
| 7   | 8    | 7   | 8        | 8 > 7 && 8 > 5 â†’ peak | âœ… found    |

**Output:**
`The peak is at index: 7`

---

### **Time Complexity:**

* **O(log N)** â†’ Binary search divides array each iteration.

### **Space Complexity:**

* **O(1)** â†’ Uses only a few variables.

---

### **Key Points:**

âœ… Works for arrays with **exactly one peak** (mountain-like).
âœ… Uses **binary search** for efficient peak detection.
âœ… Handles **edge cases** where the peak is at the start or end.

---

âœ… **In short:**
This algorithm uses **binary search** to efficiently find the index of a **peak element** in **O(log N)** time and **O(1)** space.
