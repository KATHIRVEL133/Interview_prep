Here are the **detailed coding notes** for your program ðŸ‘‡

---

### **Problem:**

Find the **index of a target element `k`** in a **rotated sorted array** using **binary search**.
If the element does not exist, return `-1`.

---

### **Intuition:**

A **rotated sorted array** is an array that was originally sorted but then rotated at some pivot point.
Example: `[1,2,3,4,5,6,7,8,9] â†’ [7,8,9,1,2,3,4,5,6]`

Even though itâ€™s rotated, one **half of the array is always sorted**.
Using this property, we can apply a **modified binary search** to find the target efficiently.

---

### **Approach / Steps:**

1. **Initialize pointers:**

   * `low = 0`
   * `high = n - 1`

2. **Iterate while `low <= high`:**

   * Calculate `mid = (low + high) / 2`
   * If `arr[mid] == k`, return `mid` (target found).

3. **Check which half is sorted:**

   * **Case 1: Left half is sorted** â†’ if `arr[low] <= arr[mid]`

     * Check if target lies in this half â†’
       if `arr[low] <= k <= arr[mid]`, move search to left (`high = mid - 1`).
     * Otherwise, search right half (`low = mid + 1`).

   * **Case 2: Right half is sorted** â†’ otherwise

     * Check if target lies in this half â†’
       if `arr[mid] <= k <= arr[high]`, move search to right (`low = mid + 1`).
     * Otherwise, search left half (`high = mid - 1`).

4. **If loop ends without finding the element:**
   Return `-1` (element not present).

---

### **Example Walkthrough:**

**Input:**
`arr = [7, 8, 9, 1, 2, 3, 4, 5, 6]`, `k = 1`

| Step | low | mid | high | arr[mid] | Sorted Half     | Action                   |
| ---- | --- | --- | ---- | -------- | --------------- | ------------------------ |
| 1    | 0   | 4   | 8    | 2        | Right is sorted | `k < arr[mid]`, go left  |
| 2    | 0   | 1   | 3    | 8        | Left is sorted  | `k < arr[low]`, go right |
| 3    | 2   | 2   | 3    | 9        | Left is sorted  | `k < arr[mid]`, go right |
| 4    | 3   | 3   | 3    | 1        | Found target âœ…  | Return index 3           |

âœ… **Output:** `The index is: 3`

---

### **Time Complexity:**

* **O(log N)** â€” Binary search halves the search space in each iteration.

### **Space Complexity:**

* **O(1)** â€” Uses only constant extra space.

---

### **Key Notes:**

* Works only for **rotated sorted arrays without duplicates**.
* For arrays with duplicates, extra conditions are required to handle equal elements.
* Common interview question â€” tests understanding of **binary search variations**.
* Example problems:

  * LeetCode #33 â€” *Search in Rotated Sorted Array*
  * Used in real-world scenarios like searching in cyclic data structures or logs.

---
