Here are **simple and clear notes** for your code ðŸ‘‡

---

## ðŸ”¹ **Program Purpose**

This program finds the **maximum subarray sum** in a given array using **Kadaneâ€™s Algorithm**.
It helps identify the contiguous subarray that gives the **largest possible sum**.

---

## ðŸ”¹ **Concept â€“ Kadaneâ€™s Algorithm**

Kadaneâ€™s Algorithm is a famous **Dynamic Programming** approach that keeps track of:

* The **current running sum** of subarray elements.
* The **maximum sum** found so far.

Whenever the running sum becomes negative, we **reset** it to zero because continuing a negative sum will only decrease the total.

---

## ðŸ”¹ **Logic Breakdown**

### ðŸ§© Step 1: Initialize

* `maxi = Long.MIN_VALUE` â†’ stores the maximum subarray sum found so far.
* `sum = 0` â†’ current running sum.

---

### ðŸ§© Step 2: Traverse the Array

For each element:

1. Add `arr[i]` to `sum`.
2. Update `maxi` if `sum > maxi`.
3. If `sum` becomes negative, reset it to `0` (start a new subarray).

---

### ðŸ§© Step 3: Return Result

After the loop ends, `maxi` holds the **maximum subarray sum**.

---

## ðŸ”¹ **Example**

**Input:** `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`

**Steps:**

* Max subarray is `[4, -1, 2, 1]`
* Sum = `6`

âœ… **Output:**
`The maximum subarray sum is: 6`

---

## ðŸ”¹ **Complexity**

* **Time Complexity:** O(N) â†’ single pass through the array
* **Space Complexity:** O(1) â†’ only variables used

---

## ðŸ§  **Summary**

âœ… Uses **Kadaneâ€™s Algorithm**
âœ… Efficient (linear time, constant space)
âœ… Resets negative running sums to optimize total
âœ… Finds the **maximum possible sum of any contiguous subarray**

Another version of problem

Here are **clear and simple notes** for your code ðŸ‘‡

---

## ðŸ”¹ **Program Purpose**

This program finds the **maximum subarray sum** and also prints the **subarray itself** using **Kadaneâ€™s Algorithm** (an optimized dynamic programming approach).

---

## ðŸ”¹ **Concept â€“ Kadaneâ€™s Algorithm**

Kadaneâ€™s Algorithm helps find the **largest sum of a contiguous subarray** in an array of integers efficiently in **O(N)** time.
It resets the sum when it becomes negative and keeps track of the **best (maximum)** sum found so far.

---

## ðŸ”¹ **Logic Breakdown**

### ðŸ§© Step 1: Initialization

* `maxi = Long.MIN_VALUE` â†’ stores the maximum subarray sum found so far.
* `sum = 0` â†’ stores the current subarray sum.
* `start, ansStart, ansEnd` â†’ used to track the indices of the subarray that gives the maximum sum.

---

### ðŸ§© Step 2: Traverse the Array

For each element `arr[i]`:

1. If `sum == 0`, mark `start = i` (possible new subarray start).
2. Add the current element to `sum`.
3. If the current `sum > maxi`, update `maxi` and record the start (`ansStart`) and end (`ansEnd`) indices.
4. If `sum < 0`, reset `sum = 0` because continuing a negative sum reduces the total.

---

### ðŸ§© Step 3: Print the Subarray

After the loop:

* Print all elements from `ansStart` to `ansEnd` â†’ this is the subarray giving the **maximum sum**.

---

### ðŸ§© Step 4: Return the Maximum Sum

Return the value stored in `maxi`.

---

## ðŸ”¹ **Example**

**Input:**
`[-2, 1, -3, 4, -1, 2, 1, -5, 4]`

**Steps:**

* The subarray `[4, -1, 2, 1]` gives the maximum sum.
* Sum = `6`

âœ… **Output:**

```
The subarray is: [4 -1 2 1 ]  
The maximum subarray sum is: 6
```

---

## ðŸ”¹ **Complexity**

* **Time Complexity:** O(N) â†’ single traversal of the array
* **Space Complexity:** O(1) â†’ uses only a few variables

---

## ðŸ§  **Summary**

âœ… Uses **Kadaneâ€™s Algorithm** to find maximum subarray sum
âœ… Also prints the **actual subarray** giving the result
âœ… Efficient â€“ linear time, constant space
âœ… Automatically skips negative running sums for optimization
