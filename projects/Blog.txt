Summary of AuthController

  Handles authentication (/signin), registration (/signup), and logout (/signout).
  Uses Spring Security + JWT for secure login.
  Role-based access: Users get roles (USER, ADMIN, MODERATOR) depending on email or request.
  Logout works by blacklisting JWT and clearing cookie.
  Ensures passwords are securely stored using PasswordEncoder.

 This is the core of your authentication system. It shows you understand JWT authentication, role-based security, and secure user registration.

Full Summary of security 

  Token lifecycle: A new JWT is generated on every login for security freshness.
  Statelessness: JWT makes the system stateless — no session storage on the server.
  Role-based security: User ↔ Role mapping ensures fine-grained access control.
  Logout handling: Achieved by token blacklisting + clearing cookie.
  Unauthorized handling: Custom AuthEntryPointJwt returns a clean JSON error response.

🔹 Elevator Pitch (2–3 sentences)

“In my Blog API, I implemented JWT-based authentication. On login, a new token is always generated and stored in a secure cookie. Each request is intercepted by a filter that validates the token, checks roles, and sets authentication in the context. On logout, tokens are blacklisted to prevent reuse. This makes the system stateless, secure, and role-based.”
“This class defines how security is handled in my application. I use a stateless JWT approach with Spring Security. Login/signup endpoints are public, while all other APIs require a valid JWT. I added a custom filter (AuthTokenFilter) to validate tokens, a BCryptPasswordEncoder for secure password storage, and CORS rules for frontend integration.”

👉 “In my Blog API project, I implemented three major controllers for Users, Posts, and Comments, each secured with role-based access control using Spring Security and JWT. 
Regular users (ROLE_USER) can interact with posts and comments (like, create, fetch) and manage their own accounts. 
Admins (ROLE_ADMIN) have extended privileges like creating/updating posts, moderating comments, and managing all users. 
I used @PreAuthorize annotations and additional checks against the authenticated user’s ID to enforce strict security. 
This ensures that users can only modify their own data while admins can oversee the entire platform.”